<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACeP 7-Color Hardware Optimizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            height: 24px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 2px solid white;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 9999px;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans pb-20">

    <header class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="bg-emerald-600 p-2 rounded-lg text-white">
                    <i data-lucide="monitor-smartphone" width="20" height="20"></i>
                </div>
                <div>
                    <h1 class="text-lg font-bold text-slate-800">ACeP 硬體校準優化器</h1>
                    <p class="text-[10px] text-emerald-600 font-bold uppercase tracking-widest">Physical Color Compensation Active</p>
                </div>
            </div>
            <div id="status-tag" class="text-[10px] bg-emerald-100 text-emerald-700 px-2 py-1 rounded-md font-bold">
                已補償 G:#005000 / B:#000050
            </div>
        </div>
    </header>

    <main class="max-w-6xl mx-auto px-4 py-8">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
          
            <!-- Left: Settings -->
            <div class="lg:col-span-4 space-y-6">
                <!-- Upload -->
                <div class="bg-white p-6 rounded-2xl border-2 border-dashed border-slate-200 hover:border-emerald-400 transition-all text-center group cursor-pointer relative">
                    <input type="file" id="fileInput" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20">
                    <div class="py-2">
                        <i data-lucide="upload-cloud" class="mx-auto mb-2 text-slate-400 group-hover:text-emerald-600 transition-colors" width="32" height="32"></i>
                        <p class="text-sm font-bold text-slate-600">更換優化圖片</p>
                    </div>
                </div>

                <!-- Controls -->
                <div class="bg-white p-6 rounded-2xl border border-slate-200 shadow-sm space-y-5">
                    <h3 class="font-bold text-slate-800 flex items-center gap-2 text-sm border-b pb-3">
                        <i data-lucide="cpu" width="16" height="16"></i> 硬體物理補償設定
                    </h3>

                    <!-- Signal Boost -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-bold text-slate-600">綠/藍 訊號增益 (Boost)</label>
                            <span id="boost-val" class="text-xs font-mono text-emerald-600">1.5x</span>
                        </div>
                        <input type="range" id="boost-input" min="100" max="300" value="150">
                        <p class="text-[10px] text-slate-400 mt-1">補償 G/B 顏料亮度不足，防止轉換後出現過多白雜點。</p>
                    </div>

                    <!-- Gamma -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-bold text-slate-600">明度展開 (Gamma)</label>
                            <span id="gamma-val" class="text-xs font-mono text-emerald-600">1.3</span>
                        </div>
                        <input type="range" id="gamma-input" min="50" max="250" value="130">
                    </div>

                    <!-- Saturation -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs font-bold text-slate-600">色彩鮮豔度</label>
                            <span id="vibe-val" class="text-xs font-mono text-emerald-600">+40%</span>
                        </div>
                        <input type="range" id="vibe-input" min="0" max="200" value="140">
                    </div>

                    <div class="pt-4 border-t border-slate-100 space-y-3">
                        <div class="flex items-center justify-between">
                            <label class="text-xs font-bold text-slate-600 italic">開啟「物理真實」預覽</label>
                            <button id="sim-btn" class="w-12 h-6 rounded-full bg-slate-200 relative transition-colors">
                                <div id="sim-dot" class="absolute left-1 top-1 w-4 h-4 bg-white rounded-full transition-transform"></div>
                            </button>
                        </div>
                        <p class="text-[10px] text-rose-500 font-medium">
                            * 開啟後，預覽圖會模擬 G:#005000 的暗度，這是面板真實表現。
                        </p>
                    </div>

                    <button id="reset-btn" class="w-full text-xs text-slate-400 hover:text-emerald-600 py-2">還原預設值</button>
                </div>
            </div>

            <!-- Right: Result -->
            <div class="lg:col-span-8 space-y-6">
                <div class="bg-white rounded-2xl border border-slate-200 shadow-sm overflow-hidden">
                    <div class="px-6 py-4 border-b border-slate-100 flex items-center justify-between">
                        <h3 class="font-bold text-slate-800 flex items-center gap-2">
                            <i data-lucide="image" width="18" height="18"></i> 補償後預覽
                        </h3>
                        <button id="download-btn" class="hidden bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg text-xs font-bold flex items-center gap-2 transition-all">
                            <i data-lucide="download-zero" width="14" height="14"></i> 下載高增益圖片
                        </button>
                    </div>
                    
                    <div class="relative min-h-[450px] bg-slate-100 flex items-center justify-center p-4">
                        <div id="loading" class="hidden absolute inset-0 bg-white/80 backdrop-blur-sm z-30 flex items-center justify-center">
                            <div class="animate-spin text-emerald-600"><i data-lucide="refresh-cw"></i></div>
                        </div>
                        <div id="empty-state" class="text-slate-300 text-center">
                            <i data-lucide="monitor-dot" width="64" height="64" class="mx-auto mb-4 opacity-20"></i>
                            <p class="text-sm">請選擇一張圖片進行物理補償</p>
                        </div>
                        <img id="main-img" class="hidden max-w-full max-h-[70vh] shadow-xl rounded-sm">
                    </div>
                </div>

                <!-- Info Cards -->
                <div class="bg-emerald-50 p-5 rounded-2xl border border-emerald-100 flex gap-4">
                    <div class="bg-emerald-600 p-2 rounded-lg h-fit text-white">
                        <i data-lucide="check-square" width="20" height="20"></i>
                    </div>
                    <div class="text-xs text-emerald-900 leading-relaxed">
                        <h4 class="font-bold mb-1 underline underline-offset-4">為什麼下載的圖片看起來「綠色很亮」？</h4>
                        <p>
                            這是為了對抗 ACeP 的 **物理暗沉**。因為您提到的 #00FF00 在面板上會縮減為 #005000，我們必須在訊號階段將圖片中的綠色區塊「推向極限明度」。<br>
                            當這張圖被 App 轉為硬體訊號時，面板會剛好顯示出您原本預期的正常綠色。
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        lucide.createIcons();

        // ACeP Signals (The 7 colors your App expects)
        const ACEP_SIGNALS = [
            { r: 255, g: 255, b: 255 }, // White
            { r: 0,   g: 0,   b: 0   }, // Black
            { r: 255, g: 0,   b: 0   }, // Red
            { r: 0,   g: 255, b: 0   }, // Signal Green
            { r: 0,   g: 0,   b: 255 }, // Signal Blue
            { r: 255, g: 255, b: 0   }, // Yellow
            { r: 255, g: 128, b: 0   }  // Orange
        ];

        // ACeP Physical Reality (What the user ACTUALLY sees)
        const ACEP_PHYSICAL = [
            { r: 255, g: 255, b: 255 }, 
            { r: 0,   g: 0,   b: 0   }, 
            { r: 255, g: 0,   b: 0   }, 
            { r: 0,   g: 80,  b: 0   }, // Physical Green (#005000 approx)
            { r: 0,   g: 0,   b: 80  }, // Physical Blue (#000050 approx)
            { r: 255, g: 255, b: 0   }, 
            { r: 255, g: 128, b: 0   }  
        ];

        let state = {
            src: null,
            vibrance: 140,
            gamma: 1.3,
            boost: 1.5,
            isSimulating: false
        };

        const els = {
            file: document.getElementById('fileInput'),
            vibe: document.getElementById('vibe-input'),
            gamma: document.getElementById('gamma-input'),
            boost: document.getElementById('boost-input'),
            simBtn: document.getElementById('sim-btn'),
            simDot: document.getElementById('sim-dot'),
            mainImg: document.getElementById('main-img'),
            loading: document.getElementById('loading'),
            empty: document.getElementById('empty-state'),
            download: document.getElementById('download-btn'),
            reset: document.getElementById('reset-btn')
        };

        function updateUI() {
            document.getElementById('vibe-val').textContent = '+' + (state.vibrance - 100) + '%';
            document.getElementById('gamma-val').textContent = state.gamma.toFixed(2);
            document.getElementById('boost-val').textContent = state.boost.toFixed(1) + 'x';
            
            els.simBtn.classList.toggle('bg-rose-500', state.isSimulating);
            els.simBtn.classList.toggle('bg-slate-200', !state.isSimulating);
            els.simDot.classList.toggle('translate-x-6', state.isSimulating);
        }

        function getNearestColorIndex(r, g, b, palette) {
            let minD = Infinity, index = 0;
            for (let i = 0; i < palette.length; i++) {
                const c = palette[i];
                let d = Math.pow(r - c.r, 2) + Math.pow(g - c.g, 2) + Math.pow(b - c.b, 2);
                if (d < minD) { minD = d; index = i; }
            }
            return index;
        }

        function process() {
            if (!state.src) return;
            els.loading.classList.remove('hidden');

            setTimeout(() => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;

                    // 1. Initial Filters
                    ctx.filter = `saturate(${state.vibrance}%)`;
                    ctx.drawImage(img, 0, 0);
                    ctx.filter = 'none';

                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;

                    // 2. Hardware Compensation Loop
                    const gInv = 1 / state.gamma;
                    const bFactor = state.boost;

                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i], g = data[i+1], b = data[i+2];

                        // Gamma correction (Open up dark areas)
                        r = 255 * Math.pow(r / 255, gInv);
                        g = 255 * Math.pow(g / 255, gInv);
                        b = 255 * Math.pow(b / 255, gInv);

                        // Specific Green/Blue Boost (Since they are physically dim)
                        // If green is dominant, boost it
                        if (g > r && g > b) {
                            g = Math.min(255, g * bFactor);
                        }
                        // If blue is dominant, boost it
                        if (b > r && b > g) {
                            b = Math.min(255, b * bFactor);
                        }

                        data[i] = r; data[i+1] = g; data[i+2] = b;
                    }
                    ctx.putImageData(imgData, 0, 0);

                    // 3. Physical Simulation (If enabled)
                    if (state.isSimulating) {
                        const simData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const d = simData.data;
                        for (let y = 0; y < canvas.height; y++) {
                            for (let x = 0; x < canvas.width; x++) {
                                const idx = (y * canvas.width + x) * 4;
                                const r = d[idx], g = d[idx+1], b = d[idx+2];
                                
                                // Map signal pixels to "Physical Reality"
                                const colorIdx = getNearestColorIndex(r, g, b, ACEP_SIGNALS);
                                const physical = ACEP_PHYSICAL[colorIdx];
                                
                                d[idx] = physical.r; d[idx+1] = physical.g; d[idx+2] = physical.b;
                                
                                // Simple Error Diffusion for better preview
                                const er = r - physical.r, eg = g - physical.g, eb = b - physical.b;
                                const distribute = (dx, dy, f) => {
                                    const ni = ((y+dy)*canvas.width + (x+dx)) * 4;
                                    if (x+dx >= 0 && x+dx < canvas.width && y+dy < canvas.height) {
                                        d[ni] += er * f; d[ni+1] += eg * f; d[ni+2] += eb * f;
                                    }
                                };
                                distribute(1,0,7/16); distribute(-1,1,3/16); distribute(0,1,5/16); distribute(1,1,1/16);
                            }
                        }
                        ctx.putImageData(simData, 0, 0);
                    }

                    els.mainImg.src = canvas.toDataURL('image/png');
                    els.mainImg.classList.remove('hidden');
                    els.empty.classList.add('hidden');
                    els.download.classList.remove('hidden');
                    els.loading.classList.add('hidden');
                };
                img.src = state.src;
            }, 50);
        }

        // Event Listeners
        els.file.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = ev => { state.src = ev.target.result; process(); };
                reader.readAsDataURL(file);
            }
        };

        els.vibe.oninput = e => { state.vibrance = +e.target.value; updateUI(); };
        els.vibe.onchange = process;
        
        els.gamma.oninput = e => { state.gamma = e.target.value / 100; updateUI(); };
        els.gamma.onchange = process;

        els.boost.oninput = e => { state.boost = e.target.value / 100; updateUI(); };
        els.boost.onchange = process;

        els.simBtn.onclick = () => { state.isSimulating = !state.isSimulating; updateUI(); process(); };

        els.reset.onclick = () => {
            state = { src: state.src, vibrance: 140, gamma: 1.3, boost: 1.5, isSimulating: false };
            els.vibe.value = 140; els.gamma.value = 130; els.boost.value = 150;
            updateUI(); process();
        };

        els.download.onclick = () => {
            // Save clean optimized version (without simulation overlay)
            const oldSim = state.isSimulating;
            state.isSimulating = false;
            
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width; canvas.height = img.height;
                ctx.filter = `saturate(${state.vibrance}%)`;
                ctx.drawImage(img, 0, 0);
                const id = ctx.getImageData(0,0,canvas.width,canvas.height);
                const d = id.data;
                const g = 1/state.gamma;
                for (let i=0; i<d.length; i+=4) {
                    d[i]=255*Math.pow(d[i]/255,g); d[i+1]=255*Math.pow(d[i+1]/255,g); d[i+2]=255*Math.pow(d[i+2]/255,g);
                    if(d[i+1]>d[i] && d[i+1]>d[i+2]) d[i+1]=Math.min(255, d[i+1]*state.boost);
                    if(d[i+2]>d[i] && d[i+2]>d[i+1]) d[i+2]=Math.min(255, d[i+2]*state.boost);
                }
                ctx.putImageData(id, 0, 0);
                const link = document.createElement('a');
                link.download = 'acep_calibrated.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                state.isSimulating = oldSim; // Restore view
            };
            img.src = state.src;
        };

        updateUI();
    </script>
</body>
</html>